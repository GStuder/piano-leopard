package net.kreatious.pianoleopard.history;

import java.io.File;
import java.io.IOException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.ShortMessage;

import net.kreatious.pianoleopard.midi.InputModel;
import net.kreatious.pianoleopard.midi.OutputModel;
import net.kreatious.pianoleopard.midi.event.Event;
import net.kreatious.pianoleopard.midi.event.NoteEvent;
import net.kreatious.pianoleopard.midi.event.PedalEvent;

import com.google.common.hash.Hashing;
import com.google.common.io.Files;

/**
 * Provides logging of keys and songs played
 *
 * @author Jay-R Studer
 */
class LogWriter {
    private class LogReader {
        private final HistoryVisitor visitor;
        private long position;
        private long timeOffset;

        private LogReader(HistoryVisitor visitor) {
            this.visitor = visitor;
        }

        /**
         * Parses the log file.
         * <p>
         * Subsequent invocations of this method resume reading from the last
         * position.
         *
         * @throws IOException
         *             if an I/O error occurs
         */
        void parse() throws IOException {
            final ByteBuffer readBuffer = ByteBuffer.allocateDirect(8192);
            final long synchronizeAt = channel.size() - readBuffer.capacity();
            while (position < synchronizeAt) {
                readBuffer.clear();
                channel.read(readBuffer, position);
                readBuffer.flip();
                parse(readBuffer);
                position += readBuffer.position();
            }

            // Synchronize with writer to prevent concurrent logfile changes
            synchronized (LogWriter.this) {
                do {
                    readBuffer.clear();
                    channel.read(readBuffer, position);
                    readBuffer.flip();
                    parse(readBuffer);
                    position += readBuffer.position();
                } while (readBuffer.position() != 0);
            }

            visitor.onParsingComplete();
        }

        private void parse(ByteBuffer readBuffer) {
            int nextPosition = readBuffer.position();
            try {
                final byte[] hash = new byte[32];
                while (readBuffer.hasRemaining()) {
                    nextPosition = readBuffer.position();
                    switch (Message.getByValue(readBuffer.get())) {
                    case KEY:
                        visitor.onKey(readBuffer.get(), readBuffer.get(), readBuffer.get(),
                                readVariableLengthLong(readBuffer), timeOffset + readVariableLengthLong(readBuffer));
                        break;
                    case START:
                        visitor.onStart(timeOffset + readVariableLengthLong(readBuffer));
                        break;
                    case FILE:
                        readBuffer.get(hash);
                        visitor.onFile(hash, timeOffset + readVariableLengthLong(readBuffer));
                        break;
                    case HEADER:
                        // fall through
                    case OFFSET_CHANGED:
                        timeOffset = readVariableLengthLong(readBuffer);
                        break;
                    default:
                        break;
                    }
                }
            } catch (final InvalidMidiDataException e) {
                e.printStackTrace();
            } catch (final BufferUnderflowException e) {
                // Rewind when reading a partial message
                readBuffer.position(nextPosition);
            }
        }
    }

    @FunctionalInterface
    private interface Payload {
        void run() throws IOException;
    }

    private final FileChannel channel;
    private final ByteBuffer buffer = ByteBuffer.allocateDirect(128);
    private final Map<HistoryVisitor, LogReader> listeners = new HashMap<>();
    private long offset = System.currentTimeMillis();

    private LogWriter(FileChannel channel) {
        this.channel = channel;
    }

    /**
     * Creates a new {@link LogWriter} that logs events generated by the user.
     *
     * @param channel
     *            the channel to write to
     * @param outputModel
     *            the {@link OutputModel} to listen to
     * @param inputModel
     *            the {@link InputModel} to listen to
     * @return a new {@link LogWriter} if the log file can be written to,
     *         otherwise an empty object.
     */
    static Optional<LogWriter> create(FileChannel channel, OutputModel outputModel, InputModel inputModel) {
        try {
            final LogWriter logger = new LogWriter(channel);
            logger.logHeader();
            outputModel.addOpenListener(sequence -> {
                logger.flush();
                sequence.getFile().ifPresent(logger::logFile);
            });
            outputModel.addPlayListener(logger::logStart);
            inputModel.addInputListener(logger::logKey);

            return Optional.of(logger);
        } catch (final IOException e) {
            e.printStackTrace();
            return Optional.empty();
        }
    }

    /**
     * Starts reading the entire log file using the specified visitor.
     * <p>
     * Before returning the specified visitor will visit the entire log file up
     * to this point.
     *
     * @param visitor
     *            the visitor associated with the listener
     * @throws IOException
     *             if an I/O error occurs
     */
    void startReading(HistoryVisitor visitor) throws IOException {
        final LogReader reader = new LogReader(visitor);
        reader.parse();

        synchronized (this) {
            listeners.put(visitor, reader);
        }
    }

    /**
     * Stops parsing notifications on the specified visitor.
     *
     * @param visitor
     *            the visitor to stop
     */
    synchronized void stopReading(HistoryVisitor visitor) {
        listeners.remove(visitor);
    }

    private synchronized void writeMessage(Message message, Payload payload) {
        try {
            writeUnhandledMessage(message, payload);

            for (final LogReader manager : listeners.values()) {
                manager.parse();
            }
        } catch (final IOException e) {
            e.printStackTrace();
        }
    }

    private synchronized void writeUnhandledMessage(Message message, Payload payload) throws IOException {
        buffer.clear();
        buffer.put(message.getHeaderByte());
        payload.run();
        buffer.flip();
        channel.write(buffer);
    }

    private synchronized void logHeader() throws IOException {
        channel.position(channel.size());
        writeUnhandledMessage(Message.HEADER, () -> writeVariableLengthLong(offset));
    }

    private synchronized void logKey(Event event) {
        if (event instanceof NoteEvent) {
            final NoteEvent noteEvent = (NoteEvent) event;
            writeMessage(Message.KEY, () -> {
                buffer.put((byte) ((event.isOn() ? ShortMessage.NOTE_ON : ShortMessage.NOTE_OFF) | noteEvent
                        .getChannel()));
                buffer.put((byte) noteEvent.getKey());
                buffer.put((byte) noteEvent.getVelocity());
                writeVariableLengthLong(System.currentTimeMillis() - offset);
                writeVariableLengthLong(event.getTime());
            });
        } else if (event instanceof PedalEvent) {
            final PedalEvent pedalEvent = (PedalEvent) event;
            writeMessage(Message.KEY, () -> {
                buffer.put((byte) (ShortMessage.CONTROL_CHANGE | event.getChannel()));
                buffer.put((byte) pedalEvent.getPedal().getData());
                buffer.put((byte) (pedalEvent.isOn() ? 127 : 0));
                writeVariableLengthLong(System.currentTimeMillis() - offset);
                writeVariableLengthLong(event.getTime());
            });
        }
    }

    private synchronized void logFile(File midi) {
        writeMessage(Message.FILE, () -> {
            buffer.put(Hashing.sha256().hashBytes(Files.toByteArray(midi)).asBytes());
            writeVariableLengthLong(System.currentTimeMillis() - offset);
        });
    }

    private synchronized void logStart() {
        offset = System.currentTimeMillis();
        writeMessage(Message.OFFSET_CHANGED, () -> writeVariableLengthLong(offset));
        writeMessage(Message.START, () -> writeVariableLengthLong(System.currentTimeMillis() - offset));
    }

    private synchronized void writeVariableLengthLong(long value) {
        long v = value;
        while ((v & ~0x7F) != 0L) {
            buffer.put((byte) (v & 0x7F));
            v >>>= 7;
        }
        buffer.put((byte) (v | 0x80));
    }

    private static long readVariableLengthLong(ByteBuffer buffer) {
        long result = 0;
        int position = 0;
        byte v;
        while (((v = buffer.get()) & 0x80) == 0x00) {
            result += (long) v << position;
            position += 7;
        }
        result += (v & 0x7FL) << position;
        return result;
    }

    private synchronized void flush() {
        try {
            channel.force(false);
        } catch (final IOException e) {
            e.printStackTrace();
        }
    }
}
